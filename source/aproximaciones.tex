\section{Aproximaciones genéricas}

\subsection{Two Pointers}
% Explicación
Two pointers es una técnica que se basa en mantener dos punteros en un arreglo, usualmente uno al inicio y otro al final, y moverlos de acuerdo a ciertas condiciones. Es útil para resolver problemas en los que se necesita recorrer un arreglo de manera eficiente, como por ejemplo encontrar un subarreglo con una suma específica. 

\subsubsection{Patrones en los enunciados que indican que se puede aplicar}
\begin{enumerate}
  \item Entradas: Los problemas generalmente involucran arreglos o cadenas como estructuras de datos principales, ya sea de tamaño fijo o dinámico. A menudo, los elementos del arreglo o cadena tienen restricciones claras (por ejemplo, enteros no negativos, caracteres alfabéticos, etc.). 
  \item Salidas: Se busca un resultado basado en relaciones entre elementos consecutivos o intervalos en las entradas, como: 
  \begin{itemize} 
    \item Encontrar un subarreglo o una subcadena con propiedades específicas (como una suma o un patrón). \item Contar el número de subarreglos o subcadenas que cumplen una condición dada. 
    \item Optimizar una métrica dentro de un rango o subsección, como maximizar una suma o minimizar una distancia. 
  \end{itemize} 
  \item Condiciones: El problema involucra relaciones que pueden ser evaluadas mediante comparación de índices, como: 
  \begin{itemize} 
    \item Moverse simultáneamente hacia el centro o hacia un punto de convergencia. 
    \item Expandir o contraer un rango (ventana) dinámicamente según una condición específica. 
  \end{itemize} 
  \item Pistas en el enunciado: 
  \begin{itemize} 
    \item Se mencionan intervalos, ventanas deslizantes, o subsecciones. 
    \item La solución requiere un enfoque eficiente para recorrer todas las combinaciones posibles (usualmente $O(n^2)$ o más lento en un enfoque directo), lo que sugiere la necesidad de optimización. 
  \end{itemize}
\end{enumerate}

\subsubsection{Problemas específicos en los que se puede aplicar}
\begin{enumerate}
  \item Dado un arreglo de números enteros, hayar:
  \begin{itemize}
    \item La cantidad de subarreglos con una suma específica. 
    \item El subarreglo con la suma más grande. 
    % Casos mas exoticos
    \item Bungee builder. 
    \item Encontrar la subcadena más larga que cumpla ciertas condiciones (ej., con un número limitado de caracteres únicos).
  \end{itemize}
\end{enumerate}

\subsection{Dynamic Programming}
% Explicación
La programación dinámica es una técnica que se basa en dividir un problema en subproblemas más pequeños, resolverlos y guardar los resultados para no tener que recalcularlos. Es útil para resolver problemas en los que se necesita recorrer un espacio de estados, como por ejemplo encontrar la cantidad de formas de llegar a un punto específico en un tablero de ajedrez. 

\subsubsection{Patrones en los enunciados que indican que se puede aplicar}
\begin{enumerate} 
  \item Entradas: Los problemas generalmente incluyen estructuras de datos como arreglos, matrices, o cadenas. Las entradas suelen tener límites moderados que permiten construir soluciones parciales iterativamente (por ejemplo, tamaños de hasta unos pocos miles). 
  \item Salidas: Se solicita optimizar una métrica (como maximizar o minimizar un valor) o contar el número de formas de alcanzar un objetivo. Ejemplos comunes incluyen: 
  \begin{itemize} 
    \item Determinar el valor óptimo de una solución (máximo, mínimo, o suma específica). \item Contar combinaciones, particiones o subsecuencias que cumplen una condición. 
    \item Resolver problemas de decisión, como verificar si es posible alcanzar un objetivo dado ciertas restricciones. 
  \end{itemize} 
  \item Subproblemas recurrentes: El problema puede dividirse en subproblemas más pequeños cuyos resultados se reutilizan para construir la solución final. Algunos patrones incluyen: 
  \begin{itemize} 
    \item Dependencia entre estados definidos por índices o por el progreso de las decisiones (por ejemplo, "¿cuál es el mejor resultado hasta el índice $i$?"). 
    \item Soluciones parciales que pueden combinarse para resolver el problema completo. 
  \end{itemize} 
  \item Pistas en el enunciado: 
  \begin{enumerate} 
    \item Se hace referencia a optimización (máximos, mínimos, caminos más cortos, etc.). \item Se menciona explícitamente la combinación de resultados parciales o subestructuras óptimas. 
    \item Las restricciones o condiciones sugieren que algunas soluciones deben recalcularse repetidamente de forma ineficiente en un enfoque ingenuo. 
    \item Los límites del problema ($n$, $m$, etc.) hacen que un enfoque de fuerza bruta no sea viable, pero se pueden procesar con una complejidad polinómica o pseudo-polinómica (como $O(n^2)$ o $O(n \cdot m)$). 
  \end{enumerate} 
\end{enumerate}

\subsubsection{Formas de obtener la función de recurrencia}

\begin{enumerate} 
  \item Definir claramente los subproblemas: Identificar cómo dividir el problema principal en partes más pequeñas y manejables. Cada subproblema debe depender únicamente de una o más de sus versiones anteriores. 
  \begin{itemize} 
    \item Pregúntate: "¿Qué representa el estado $dp[i]$?" (por ejemplo, el mejor resultado hasta el índice $i$, la cantidad de maneras de llegar al estado $i$, etc.). 
  \end{itemize} 
  \item Establecer relaciones entre subproblemas: Analiza cómo combinar las soluciones de subproblemas para construir la solución del problema mayor. Esto usualmente se traduce en una relación matemática o lógica basada en las decisiones posibles en cada estado. 
  \item Examinar las opciones en cada paso: Identifica las decisiones que se pueden tomar en cada etapa del problema. Por ejemplo, ¿puedes incluir o excluir un elemento? ¿Moverte a un estado vecino? Cada decisión debe ser considerada para construir la recurrencia. 
  \item Asegurar la optimalidad o completitud: Confirma que cada subproblema se resuelve de manera óptima o completa antes de pasar al siguiente. Esto asegura que la solución global se construya correctamente. 
  \item Usar ejemplos concretos: Trabaja con casos pequeños para identificar patrones o relaciones que generalicen la recurrencia. Esto puede ayudarte a encontrar errores o confirmar que los subproblemas están correctamente definidos. 
\end{enumerate}

\subsubsection{Problemas específicos que se resuelven con programación dinámica}

\begin{enumerate} 
  \item Knapsack Problem.

  \item Longest Common Subsequence.

  \item Interleaving Strings.

  \item Minimum Path Sum.

  \item Palindrome Partitioning.

  \item Coin Change.

  \item Triangle Path Sum.

  \item Rod Cutting.

  \item Longest Increasing Subsequence.

  \item Problema del comerciante viajero con restricciones. 
\end{enumerate}

\subsection{}

\subsection{Divide and Conquer}

\subsection{DFS}

\subsection{BFS}

\subsection{Binary Search}

\subsection{Backtracking}

\subsection{Greedy}

