\section{Snippets}

\subsection{Comparador}
\label{subsec:comparador}
% Explicacion
Un comparador es una función que se utiliza para ordenar los elementos de un contenedor de una forma específica. En C++, los comparadores son funciones que retornan un valor booleano siendo \texttt{true} si el primer argumento debe ir antes que el segundo y \texttt{false} en caso contrario.

\subsubsection{Ejemplo:}
\begin{lstlisting}
bool cmp(int a, int b) {
  return a > b;
}
\end{lstlisting}

\subsection{std::sort}
\label{subsec:std_sort}
% Explicacion
La función \texttt{std::sort} ordena los elementos de un contenedor en orden ascendente. Si se desea ordenar en orden descendente, se puede utilizar un comparador (ver \ref{subsec:comparador}).

\subsubsection{Implementacion:}
\begin{lstlisting}
std::sort(v.begin(), v.end(), comp);
\end{lstlisting}

\subsection{std::stable\_sort}
\label{subsec:std_stable_sort}
% Explicacion
La función \texttt{std::stable\_sort} ordena los elementos de un contenedor en orden ascendente. A diferencia de \texttt{std::sort}, esta función mantiene el orden relativo de los elementos que son iguales.

\subsubsection{Implementacion:}
\begin{lstlisting}
std::stable_sort(v.begin(), v.end(), comp);
\end{lstlisting}

\subsection{std::binary\_search}
\label{subsec:std_binary_search}
% Explicacion
La función \texttt{std::binary\_search} busca un elemento en un contenedor ordenado. Retorna \texttt{true} si el elemento se encuentra en el contenedor y \texttt{false} en caso contrario.

\subsubsection{Implementacion:}
\begin{lstlisting}
std::binary_search(v.begin(), v.end(), x);
\end{lstlisting}

\subsection{std::lower\_bound}
\label{subsec:std_lower_bound}
% Explicacion
La función \texttt{std::lower\_bound} retorna un iterador al primer elemento en un contenedor cuyo comparador retorne \texttt{false} para el valor dado.

\subsubsection{Implementacion:}
\begin{lstlisting}
std::lower_bound(v.begin(), v.end(), x, comp);
\end{lstlisting}

\subsection{std::upper\_bound}
\label{subsec:std_upper_bound}
% Explicacion
La función \texttt{std::upper\_bound} retorna un iterador al primer elemento en un contenedor cuyo comparador retorne \texttt{true} para el valor dado.

\subsubsection{Implementacion:}
\begin{lstlisting}
std::upper_bound(v.begin(), v.end(), x, comp);
\end{lstlisting}

\subsection{std::reverse}
\label{subsec:std_reverse}
% Explicacion
La función \texttt{std::reverse} invierte el orden de los elementos de un contenedor en $O(n)$. 

\subsubsection{Implementacion:}
\begin{lstlisting}
std::reverse(v.begin(), v.end());
\end{lstlisting}

\subsection{std::next\_permutation}
\label{subsec:std_next_permutation}
% Explicacion
La función \texttt{std::next\_permutation} reordena los elementos de un contenedor en la siguiente permutación lexicográfica. Retorna \texttt{true} si la siguiente permutación existe y \texttt{false} en caso contrario. 


\subsubsection{Implementacion:}
\begin{lstlisting}
std::next_permutation(v.begin(), v.end());
\end{lstlisting}


Para obtener todas las permutaciones de un contenedor, se puede utilizar un ciclo \texttt{do-while} asegurandose que este este ordenado en orden ascendente antes de empezar. 

\begin{lstlisting}
std::sort(v.begin(), v.end());

do {
  // Procesar la permutacion
} while(std::next_permutation(v.begin(), v.end()));
\end{lstlisting}

\subsection{std::prev\_permutation}
\label{subsec:std_prev_permutation}
% Explicacion
La función \texttt{std::prev\_permutation} reordena los elementos de un contenedor en la permutación lexicográfica anterior. Retorna \texttt{true} si la permutación anterior existe y \texttt{false} en caso contrario. 

\subsubsection{Implementacion:}
\begin{lstlisting}
std::prev_permutation(v.begin(), v.end());
\end{lstlisting}

Para obtener todas las permutaciones de un contenedor, se puede utilizar un ciclo \texttt{do-while} asegurandose que este este ordenado en orden descendente antes de empezar.

\subsection{std::accumulate}
\label{subsec:std_accumulate}
% Explicacion
La función \texttt{std::accumulate} calcula la suma de los elementos de un contenedor. Complejidad $O(n)$. 

\subsubsection{Implementacion:}
\begin{lstlisting}
int sum = std::accumulate(v.begin(), v.end(), 0);
\end{lstlisting}

\subsection{std::partial\_sum}
\label{subsec:std_partial_sum}
% Explicacion
La función \texttt{std::partial\_sum} calcula la suma acumulada de los elementos de un contenedor. El resultado se almacena en otro contenedor. Complejidad $O(n)$.

\subsubsection{Implementacion:}
\begin{lstlisting}
vector<int> acm = {1, 2, 3, 4, 5};
std::partial_sum(acm.begin(), acm.end(), acm.begin());
// acm = {1, 3, 6, 10, 15}
\end{lstlisting}

\subsection{std::inner\_product}
\label{subsec:std_inner_product}
% Explicacion
La función \texttt{std::inner\_product} calcula el producto punto de dos contenedores. Complejidad $O(n)$.

\subsubsection{Implementacion:}
\begin{lstlisting}
// Recibe unicamente un end iterator porque ambos contenedores deben tener la misma longitud
int dot = std::inner_product(v1.begin(), v1.end(), v2.begin(), 0);
\end{lstlisting}

\subsection{std::adjacent\_difference}
\label{subsec:std_adjacent_difference}
% Explicacion
La función \texttt{std::adjacent\_difference} calcula la diferencia entre elementos consecutivos de un contenedor. El resultado se almacena en otro contenedor. Complejidad $O(n)$.

\subsubsection{Implementacion:}
\begin{lstlisting}
vector<int> diff = {1, 2, 4, 7, 11};
// Recibe tres iteradores para el comienzo contenedor, el final del contenedor y el valor inicial
std::adjacent_difference(diff.begin(), diff.end(), diff.begin());
// diff = {1, 1, 2, 3, 4}
\end{lstlisting}

El valor inicial es el valor que se le asigna al primer elemento del contenedor resultado.

\subsection{std::iota}
\label{subsec:std_iota}
% Explicacion 
La función \texttt{std::iota} asigna valores consecutivos a los elementos de un contenedor. Complejidad $O(n)$. 

\subsubsection{Implementacion:}
\begin{lstlisting}
// v = {0, 0, 0, 0, 0}
std::iota(v.begin(), v.end(), 1);
// v = {1, 2, 3, 4, 5}
\end{lstlisting}
